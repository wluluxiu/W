Shader "postprocessing/depthOfField"{

    Properties {
		_uMainTex ( "main texture", 2D ) = "" {}
        _CameraMotionVectorsTexture ("Camera Motion Vectors Texture", 2D) = "" {}
        _distance ( "distance", float ) = 0
        _lensCoeff ( "lensCoeff", float ) = 0
        _maxCoC ("maxCoC" , float) = 0
        _rcpMaxCoC ( "rcpMaxCoC", float ) = 0
        _rcpAspect ( "rcpAspect", float ) = 0
        _taaParams ( "taaParams", vector ) = (0,0,0,0)
	}

    CGINC
    #define PI              3.14159265359
    #include "CG.cginc"
    #include "Sampling.cginc"

	uniform sampler2D _uMainTex;
    uniform sampler2D _CoCTex;
    uniform sampler2D _DepthOfFieldTex;
    uniform sampler2D _CameraMotionVectorsTexture;
	DECLARE_DEPTH_TEXTURE(gCameraDepthTexture);	
    uniform float _distance;
    uniform float _lensCoeff;
    uniform float _maxCoC;
    uniform float _rcpMaxCoC;
    uniform float _rcpAspect;
    uniform half3 _taaParams;
    uniform float4 _uMainTex_TexelSize;

	struct appdata_t {
		float4 pos : POSITION;
		float2 texcoord : TEXCOORD0;
	};

	struct v2f {
		float4 pos : SV_POSITION;
		float2 texcoord : TEXCOORD0;
	};

    float DepthOfFieldLinearEyeDepth(float depth)
    {
        float near = 0.1f;
        float far = 500.0f;
        float x = (-1.0f + far) / near;
        float z = x / far;
        float w = 1.0f / far;
        return 1.0f / (z * depth + w);
    }

	half Weigh (half coc, half radius, half margin) {
		return saturate((coc - radius + margin) / margin);
	}

    half Weigh (half3 c) {
		return (1 + max(max(c.r, c.g), c.b));
	}
    
    // CoC calculation
    half4 FragCoC(v2f i) : SV_Target
    {
        float zdepth = SAMPLE_DEPTH_TEXTURE(gCameraDepthTexture,i.texcoord);

        zdepth = 1 - zdepth;
        
        float depth = DepthOfFieldLinearEyeDepth(zdepth);

        half coc = (depth  - _distance) * _lensCoeff   / max(depth, 1e-4);
        return saturate(coc * 0.5 * _rcpMaxCoC  + 0.5);
    }

    // Temporal filter
    half4 FragTempFilter(v2f i) : SV_Target
    {
        float3 uvOffs = _uMainTex_TexelSize.xyy * float3(1.0, 1.0, 0.0);


        half coc1 = tex2D(_CoCTex,saturate(i.texcoord - uvOffs.xz)).r * 2.0 - 1.0; // top
        half coc2 = tex2D(_CoCTex,saturate(i.texcoord - uvOffs.zy)).r * 2.0 - 1.0; // left
        half coc3 = tex2D(_CoCTex,saturate(i.texcoord + uvOffs.zy)).r * 2.0 - 1.0; // bottom
        half coc4 = tex2D(_CoCTex,saturate(i.texcoord + uvOffs.xz)).r * 2.0 - 1.0; // right

        // Dejittered center sample.
        half coc0 = tex2D(_CoCTex,saturate(i.texcoord - _taaParams.xy)).r * 2.0 - 1.0;

        // CoC dilation: determine the closest point in the four neighbors
        float3 closest = float3(0.0, 0.0, coc0);
        closest = coc1 < closest.z ? float3(-uvOffs.xz, coc1) : closest;
        closest = coc2 < closest.z ? float3(-uvOffs.zy, coc2) : closest;
        closest = coc3 < closest.z ? float3( uvOffs.zy, coc3) : closest;
        closest = coc4 < closest.z ? float3( uvOffs.xz, coc4) : closest;

        // Sample the history buffer with the motion vector at the closest point
        float2 motion = tex2D(_CameraMotionVectorsTexture , saturate(i.texcoord + closest.xy)).xy;
        half cocHis = tex2D(_uMainTex , saturate(i.texcoord - motion)).r;

        // Neighborhood clamping
        half cocMin = closest.z;
        half cocMax = Max3(Max3(coc0, coc1, coc2), coc3, coc4);
        cocHis = clamp(cocHis, cocMin, cocMax);

        // Blend with the history
        return lerp(coc0, cocHis, _taaParams.z);
    }

    // Prefilter: downsampling and premultiplying
    half4 FragPrefilter(v2f i) : SV_Target
    {
		float4 o = _uMainTex_TexelSize.xyxy * float2(-0.5, 0.5).xxyy;
        half3 s0 = tex2D(_uMainTex, i.texcoord + o.xy).rgb;
		half3 s1 = tex2D(_uMainTex, i.texcoord + o.zy).rgb;
		half3 s2 = tex2D(_uMainTex, i.texcoord + o.xw).rgb;
		half3 s3 = tex2D(_uMainTex, i.texcoord + o.zw).rgb;

		half coc0 = tex2D(_CoCTex, i.texcoord + o.xy).r * 2.0 - 1.0;
		half coc1 = tex2D(_CoCTex, i.texcoord + o.zy).r * 2.0 - 1.0;
		half coc2 = tex2D(_CoCTex, i.texcoord + o.xw).r * 2.0 - 1.0;
		half coc3 = tex2D(_CoCTex, i.texcoord + o.zw).r * 2.0 - 1.0;

        half w0 = abs(coc0) / Weigh(s0);
		half w1 = abs(coc1) / Weigh(s1);
		half w2 = abs(coc2) / Weigh(s2);
		half w3 = abs(coc3) / Weigh(s3);

		half3 color = s0 * w0 + s1 * w1 + s2 * w2 + s3 * w3;
		color /= max(w0 + w1 + w2 + w3, 1e-4);
					
		half cocMin = min(min(min(coc0, coc1), coc2), coc3);
		half cocMax = max(max(max(coc0, coc1), coc2), coc3);
		half coc = (cocMax >= -cocMin ? cocMax : cocMin) * _maxCoC;

        color *= smoothstep(0, _uMainTex_TexelSize.y * 2, abs(coc));


		return half4(color,coc);
        
    }

    // Postfilter blur
    half4 FragPostBlur(v2f i) : SV_Target
    {
	    float4 o = _uMainTex_TexelSize.xyxy * float2(-0.5, 0.5).xxyy;
		half4 s =
			tex2D(_uMainTex, i.texcoord + o.xy) +
			tex2D(_uMainTex, i.texcoord + o.zy) +
			tex2D(_uMainTex, i.texcoord + o.xw) +
			tex2D(_uMainTex, i.texcoord + o.zw);
		return s * 0.25;
    }

    // Combine with source
    half4 FragCombine(v2f i) : SV_Target
    {
		half4 source = tex2D(_uMainTex, i.texcoord);
		half coc = (tex2D(_CoCTex, i.texcoord).r - 0.5) * 2.0 * _maxCoC;
		half4 dof = tex2D(_DepthOfFieldTex, i.texcoord);
   
        half alpha = Max3(dof.r, dof.g, dof.b);

		half dofStrength = smoothstep(_uMainTex_TexelSize.y * 2.0, _uMainTex_TexelSize.y * 4.0, coc);
		half4 color = lerp(
			source, float4(dof.rgb ,alpha) ,
			dofStrength + dof.a - dofStrength * dof.a
		);

		return color;
    }


	v2f vert (appdata_t v) {
		v2f o;
		o.pos = mul( uMVPMatrix, v.pos );
		o.texcoord = v.texcoord;
		return o;
	}

    ENDCG

    SubShader{
        Cull Off
        ZWrite Off 
        ZTest Always

        // Pass 0
        Pass {
            Name "CoC Calculation"

			CGPROGRAM

			#pragma vertex vert
            #pragma fragment FragCoC
			
			ENDCG
		}

        // Pass 1
        Pass {
            Name "CoC Temporal Filter"

			CGPROGRAM

			#pragma vertex vert
            #pragma fragment FragTempFilter
			
			ENDCG
		}

        // Pass 2
        Pass {
            Name "Downsample and Prefilter"

			CGPROGRAM

			#pragma vertex vert
            #pragma fragment FragPrefilter
			
			ENDCG
		}

        // Pass 3
        Pass {
            Name "Bokeh Filter"

			CGPROGRAM
            #pragma multi_compile_local __ KERNEL_SMALL
            #pragma multi_compile_local __ KERNEL_MEDIUM
            #pragma multi_compile_local __ KERNEL_LARGE
            #pragma multi_compile_local __ KERNEL_VERYLARGE
            #if KERNEL_SMALL
                // rings = 2
                // points per ring = 5
                static const int kSampleCount = 16;
                static const float2 kDiskKernel[16] = {
                    float2(0,0),
                    float2(0.54545456,0),
                    float2(0.16855472,0.5187581),
                    float2(-0.44128203,0.3206101),
                    float2(-0.44128197,-0.3206102),
                    float2(0.1685548,-0.5187581),
                    float2(1,0),
                    float2(0.809017,0.58778524),
                    float2(0.30901697,0.95105654),
                    float2(-0.30901703,0.9510565),
                    float2(-0.80901706,0.5877852),
                    float2(-1,0),
                    float2(-0.80901694,-0.58778536),
                    float2(-0.30901664,-0.9510566),
                    float2(0.30901712,-0.9510565),
                    float2(0.80901694,-0.5877853),
            };


            #elif KERNEL_MEDIUM

            // rings = 3
            // points per ring = 7
                static const int kSampleCount = 22;
                static const float2 kDiskKernel[22] = {
                    float2(0,0),
                    float2(0.53333336,0),
                    float2(0.3325279,0.4169768),
                    float2(-0.11867785,0.5199616),
                    float2(-0.48051673,0.2314047),
                    float2(-0.48051673,-0.23140468),
                    float2(-0.11867763,-0.51996166),
                    float2(0.33252785,-0.4169769),
                    float2(1,0),
                    float2(0.90096885,0.43388376),
                    float2(0.6234898,0.7818315),
                    float2(0.22252098,0.9749279),
                    float2(-0.22252095,0.9749279),
                    float2(-0.62349,0.7818314),
                    float2(-0.90096885,0.43388382),
                    float2(-1,0),
                    float2(-0.90096885,-0.43388376),
                    float2(-0.6234896,-0.7818316),
                    float2(-0.22252055,-0.974928),
                    float2(0.2225215,-0.9749278),
                    float2(0.6234897,-0.7818316),
                    float2(0.90096885,-0.43388376),
            };


            #elif KERNEL_LARGE

                // rings = 4
                // points per ring = 7
                static const int kSampleCount = 43;
                static const float2 kDiskKernel[43] = {
                    float2(0,0),
                    float2(0.36363637,0),
                    float2(0.22672357,0.28430238),
                    float2(-0.08091671,0.35451925),
                    float2(-0.32762504,0.15777594),
                    float2(-0.32762504,-0.15777591),
                    float2(-0.08091656,-0.35451928),
                    float2(0.22672352,-0.2843024),
                    float2(0.6818182,0),
                    float2(0.614297,0.29582983),
                    float2(0.42510667,0.5330669),
                    float2(0.15171885,0.6647236),
                    float2(-0.15171883,0.6647236),
                    float2(-0.4251068,0.53306687),
                    float2(-0.614297,0.29582986),
                    float2(-0.6818182,0),
                    float2(-0.614297,-0.29582983),
                    float2(-0.42510656,-0.53306705),
                    float2(-0.15171856,-0.66472363),
                    float2(0.1517192,-0.6647235),
                    float2(0.4251066,-0.53306705),
                    float2(0.614297,-0.29582983),
                    float2(1,0),
                    float2(0.9555728,0.2947552),
                    float2(0.82623875,0.5633201),
                    float2(0.6234898,0.7818315),
                    float2(0.36534098,0.93087375),
                    float2(0.07473,0.9972038),
                    float2(-0.22252095,0.9749279),
                    float2(-0.50000006,0.8660254),
                    float2(-0.73305196,0.6801727),
                    float2(-0.90096885,0.43388382),
                    float2(-0.98883086,0.14904208),
                    float2(-0.9888308,-0.14904249),
                    float2(-0.90096885,-0.43388376),
                    float2(-0.73305184,-0.6801728),
                    float2(-0.4999999,-0.86602545),
                    float2(-0.222521,-0.9749279),
                    float2(0.07473029,-0.99720377),
                    float2(0.36534148,-0.9308736),
                    float2(0.6234897,-0.7818316),
                    float2(0.8262388,-0.56332),
                    float2(0.9555729,-0.29475483),
            };

            #elif KERNEL_VERYLARGE

                // rings = 5
                // points per ring = 7
                static const int kSampleCount = 71;
                static const float2 kDiskKernel[71] = {
                    float2(0,0),
                    float2(0.2758621,0),
                    float2(0.1719972,0.21567768),
                    float2(-0.061385095,0.26894566),
                    float2(-0.24854316,0.1196921),
                    float2(-0.24854316,-0.11969208),
                    float2(-0.061384983,-0.2689457),
                    float2(0.17199717,-0.21567771),
                    float2(0.51724136,0),
                    float2(0.46601835,0.22442262),
                    float2(0.32249472,0.40439558),
                    float2(0.11509705,0.50427306),
                    float2(-0.11509704,0.50427306),
                    float2(-0.3224948,0.40439552),
                    float2(-0.46601835,0.22442265),
                    float2(-0.51724136,0),
                    float2(-0.46601835,-0.22442262),
                    float2(-0.32249463,-0.40439564),
                    float2(-0.11509683,-0.5042731),
                    float2(0.11509732,-0.504273),
                    float2(0.32249466,-0.40439564),
                    float2(0.46601835,-0.22442262),
                    float2(0.7586207,0),
                    float2(0.7249173,0.22360738),
                    float2(0.6268018,0.4273463),
                    float2(0.47299224,0.59311354),
                    float2(0.27715522,0.7061801),
                    float2(0.056691725,0.75649947),
                    float2(-0.168809,0.7396005),
                    float2(-0.3793104,0.65698475),
                    float2(-0.55610836,0.51599306),
                    float2(-0.6834936,0.32915324),
                    float2(-0.7501475,0.113066405),
                    float2(-0.7501475,-0.11306671),
                    float2(-0.6834936,-0.32915318),
                    float2(-0.5561083,-0.5159932),
                    float2(-0.37931028,-0.6569848),
                    float2(-0.16880904,-0.7396005),
                    float2(0.056691945,-0.7564994),
                    float2(0.2771556,-0.7061799),
                    float2(0.47299215,-0.59311366),
                    float2(0.62680185,-0.4273462),
                    float2(0.72491735,-0.22360711),
                    float2(1,0),
                    float2(0.9749279,0.22252093),
                    float2(0.90096885,0.43388376),
                    float2(0.7818315,0.6234898),
                    float2(0.6234898,0.7818315),
                    float2(0.43388364,0.9009689),
                    float2(0.22252098,0.9749279),
                    float2(0,1),
                    float2(-0.22252095,0.9749279),
                    float2(-0.43388385,0.90096885),
                    float2(-0.62349,0.7818314),
                    float2(-0.7818317,0.62348956),
                    float2(-0.90096885,0.43388382),
                    float2(-0.9749279,0.22252093),
                    float2(-1,0),
                    float2(-0.9749279,-0.22252087),
                    float2(-0.90096885,-0.43388376),
                    float2(-0.7818314,-0.6234899),
                    float2(-0.6234896,-0.7818316),
                    float2(-0.43388346,-0.900969),
                    float2(-0.22252055,-0.974928),
                    float2(0,-1),
                    float2(0.2225215,-0.9749278),
                    float2(0.4338835,-0.90096897),
                    float2(0.6234897,-0.7818316),
                    float2(0.78183144,-0.62348986),
                    float2(0.90096885,-0.43388376),
                    float2(0.9749279,-0.22252086),
            };

            #else
                static const int kSampleCount = 1;
                static const float2 kDiskKernel[1] = { float2(0, 0) };
            #endif
            // Bokeh filter with disk-shaped kernels
            half4 FragBlur(v2f i) : SV_Target
            {

                half3 bgColor = 0, fgColor = 0;
                half bgWeight = 0, fgWeight = 0;

                half margin = _uMainTex_TexelSize.y * 2;
                half4 coc = tex2D(_uMainTex, i.texcoord);
                for (int k = 0; k < kSampleCount; k++) {
                    float2 o = kDiskKernel[k] * _maxCoC;
                    half radius = length(o);
                    float2 duv = float2(o.x * _rcpAspect, o.y);
                    half4 s = tex2D(_uMainTex, i.texcoord + duv);
                    half bgw = Weigh(max(0, min(s.a, coc.a)), radius, margin);
                    bgColor += s.rgb * bgw;
                    bgWeight += bgw;

                    half fgw = Weigh(-s.a, radius,margin);
                    fgw  *= step(_uMainTex_TexelSize.y, -s.a);

                    fgColor += s.rgb * fgw;
                    fgWeight += fgw;
                }
                bgColor /= (bgWeight + (bgWeight == 0.0f));
                fgColor /= (fgWeight + (fgWeight == 0.0f));
                half bgfg = fgWeight * 3.14159265359  / kSampleCount;
                half alpha = saturate(bgfg);
                half3 color = lerp(bgColor, fgColor, alpha);
                return half4(color, alpha);
            
            }

			#pragma vertex vert
            #pragma fragment FragBlur


			
			ENDCG
		}

        // Pass 4
        Pass {
            Name "Postfilter"

			CGPROGRAM

			#pragma vertex vert
            #pragma fragment FragPostBlur
			
			ENDCG
		}

        // Pass 5
        Pass {
            Name "Combine"

			CGPROGRAM

			#pragma vertex vert
            #pragma fragment FragCombine
			
			ENDCG
		}
    }
}