Shader "TMP/Bitmap" {
	Properties {
		_uMainTex		("Font Atlas", 2D) = "white" {}
		_uFaceTex		("Font Texture", 2D) = "white" {}
		_uFaceTex_ST    ("Font Texture ST", Vector) = (1,1,0,0)
		[HDR]_uFaceColor	("Text Color", Color) = (1,1,1,1)
	
		_uVertexOffsetX	("Vertex OffsetX", Float) = 0
		_uVertexOffsetY	("Vertex OffsetY", Float) = 0
	
		_uStencilComp("Stencil Comparison", Float) = 7
		_uStencil("Stencil ID", Float) = 0
		_uStencilOp("Stencil Operation", Float) = 0
		_uStencilWriteMask("Stencil Write Mask", Float) = 255
		_uStencilReadMask("Stencil Read Mask", Float) = 255
	
		_uCullMode("Cull Mode", Float) = 0
		_uColorMask("Color Mask", Float) = 15
	}
	SubShader {
		Tags
		{        
			"Queue"="Transparent"
            "PreviewType"="Plane"
		}
			
		Stencil
        {
            Ref [_uStencil]
            Comp [_uStencilComp]
            Pass [_uStencilOp]
            ReadMask [_uStencilReadMask]
            WriteMask [_uStencilWriteMask]
        }
		
		Cull[_uCullMode]
        ZTest [gGUIZTestMode]
		ZWrite Off
        Blend SrcAlpha OneMinusSrcAlpha
        ColorMask [_uColorMask]
		
		Pass {
					
			CGPROGRAM
			
			#include "CG.cginc"
            #include "UI.cginc"
			
			#pragma multi_compile_local __ UI_CLIP_RECT
            #pragma multi_compile_local __ UI_ALPHACLIP
			
			uniform sampler2D 	_uMainTex;
			uniform float4 		_uMainTex_ST;
			uniform	sampler2D 	_uFaceTex;
			uniform float4		_uFaceTex_ST;
			uniform	fixed4		_uFaceColor;

			uniform float		_uVertexOffsetX;
			uniform float		_uVertexOffsetY;
			
            uniform float4 		gClipRect;
            uniform float		gUIMaskSoftnessX;
            uniform float 		gUIMaskSoftnessY;
			
			struct appdata_t {
				float4 pos   	: POSITION;
                float4 color    : COLOR;
                float2 uv 		: TEXCOORD0;
				float2 uv1		: TEXCOORD1;
			};
			struct v2f {
				float4 pos   	: SV_POSITION;
                fixed4 color    : COLOR;
				float2	uv0		: TEXCOORD0;
				float2	uv1		: TEXCOORD1;
				float4	mask	: TEXCOORD2;
			};
			float2 UnpackUV(float uv)
			{
				float2 output;
				output.x = floor(uv / 4096);
				output.y = uv - 4096 * output.x;
	
				return output * 0.001953125;
			}

			v2f vert (appdata_t v)
			{
				float4 vert = v.pos;
				vert.x += _uVertexOffsetX;
				vert.y += _uVertexOffsetY;
	
				vert.xy += (vert.w * 0.5) / uViewportSize.xy;
	
				float4 vPosition = PixelSnap(mul(uMVPMatrix, vert));
	
				fixed4 faceColor = v.color;
				faceColor *= _uFaceColor;
				
				float4 worldpos = mul( uMMatrix, v.pos );
				
				v2f OUT;
				OUT.pos = vPosition;
				OUT.color = faceColor;
				OUT.uv0 = v.uv;
				OUT.uv1 = TRANSFORM_TEX(UnpackUV(v.uv1), _uFaceTex);
				float2 pixelSize = vPosition.w;
                pixelSize /= float2(1, 1) * abs(mul((float2x2)uPMatrix, uViewportSize.xy));
	
				// Clamp _uClipRect to 16bit.
				float4 clampedRect = clamp(gClipRect, -2e10, 2e10);
				OUT.mask = float4(worldpos.xy * 2 - clampedRect.xy - clampedRect.zw, 0.25 / (0.25 * half2(gUIMaskSoftnessX, gUIMaskSoftnessY) + abs(pixelSize.xy)));
	
				return OUT;
			}
			
			float4 frag(v2f i) : SV_TARGET {
				fixed4 color = tex2D(_uMainTex, i.uv0);
				color = fixed4 (tex2D(_uFaceTex, i.uv1).rgb * i.color.rgb, i.color.a * color.a);
	
				// Alternative implementation to UnityGet2DClipping with support for softness.
				#if UI_CLIP_RECT
					half2 m = saturate((gClipRect.zw - gClipRect.xy - abs(i.mask.xy)) * i.mask.zw);
					color *= m.x * m.y;
				#endif
	
				#if UI_ALPHACLIP
					clip(color.a - 0.001);
				#endif
	
				return color;
			}
			
			ENDCG
		}
	}
}