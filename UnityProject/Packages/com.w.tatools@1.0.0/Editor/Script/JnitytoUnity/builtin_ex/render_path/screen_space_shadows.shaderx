Shader "hidden/screen_space_shadows" {
	Properties {
		_ZBufferParams("ZBufferParams",vector) = (1,1,1,1)
	}

	SubShader {
		Pass {
			ZWrite Off ZTest Always 
			Cull Off

			CGPROGRAM
			
			#pragma multi_compile_shadowcollector

			#pragma vertex vert
			#pragma fragment frag
			
			#include "CG.cginc"
			
			DECLARE_DEPTH_TEXTURE(gCameraDepthTexture);	
			DECLARE_SHADOWMAP(gShadowMapTexture);
		    uniform float4 gShadowMapTexture_TexelSize;	
			#define SHADOWMAPSAMPLER_AND_TEXELSIZE_DEFINED	
			uniform float4 _ZBufferParams;

			#include "ShadowLibrary.cginc"

			struct v2f {
				float4 pos : SV_POSITION;
				float2 uv : TEXCOORD0;
				float3 ray : TEXCOORD1;
			};

			//
			// Keywords based defines
			//
			#if defined (SHADOWS_SPLIT_SPHERES)
				#define GET_CASCADE_WEIGHTS(wpos, z)    getCascadeWeights_splitSpheres(wpos)
				float calcuteShadowFade(float3 worldPos, float3 viewPos) {
					float sphereDist = distance(worldPos.xyz, uShadowFadeCenterAndType.xyz); 
					float shadowFade = saturate(sphereDist * uLightShadowData.z + uLightShadowData.w);
					return shadowFade;
				}
			#else
				#define GET_CASCADE_WEIGHTS(wpos, z)    getCascadeWeights( wpos, z )
				float calcuteShadowFade(float3 worldPos, float3 viewPos) {
					float shadowFade = saturate((-1.0) * viewPos.z * uLightShadowData.z + uLightShadowData.w);
					return shadowFade;
				}
			#endif

			#define GET_SHADOW_COORDINATES(wpos,cascadeWeights) getShadowCoord(wpos,cascadeWeights)

			/**
			* Gets the cascade weights based on the world position of the fragment.
			* Returns a float4 with only one component set that corresponds to the appropriate cascade.
			*/
			inline float4 getCascadeWeights(float3 wpos, float z)
			{
				float4 zNear = float4( z >= uLightSplitsNear );
				float4 zFar = float4( z < uLightSplitsFar );

				float4 weights = zNear * zFar;
				return weights;
			}

			/**
			* Gets the cascade weights based on the world position of the fragment and the poisitions of the split spheres for each cascade.
			* Returns a float4 with only one component set that corresponds to the appropriate cascade.
			*/
			inline float4 getCascadeWeights_splitSpheres(float3 wpos)
			{
				float3 fromCenter0 = wpos.xyz - uShadowSplitSpheres0.xyz;
				float3 fromCenter1 = wpos.xyz - uShadowSplitSpheres1.xyz;
				float3 fromCenter2 = wpos.xyz - uShadowSplitSpheres2.xyz;
				float3 fromCenter3 = wpos.xyz - uShadowSplitSpheres3.xyz;
				float4 distances2 = float4(dot(fromCenter0,fromCenter0), dot(fromCenter1,fromCenter1), dot(fromCenter2,fromCenter2), dot(fromCenter3,fromCenter3));
				float4 weights = float4(distances2 < uShadowSplitSqRadii);

				weights.yzw = saturate(weights.yzw - weights.xyz);
				return weights;
			}

			/**
			* Returns the shadowmap coordinates for the given fragment based on the world position and z-depth.
			* These coordinates belong to the shadowmap atlas that contains the maps for all cascades.
			*/
			inline float4 getShadowCoord( float4 wpos, float4 cascadeWeights )
			{
				float3 sc0 = mul (uWorldToShadow0, wpos).xyz;
				float3 sc1 = mul (uWorldToShadow1, wpos).xyz;
				float3 sc2 = mul (uWorldToShadow2, wpos).xyz;
				float3 sc3 = mul (uWorldToShadow3, wpos).xyz;
				float4 shadowMapCoordinate = float4(sc0 * cascadeWeights[0] + sc1 * cascadeWeights[1] + sc2 * cascadeWeights[2] + sc3 * cascadeWeights[3], 1);
				return shadowMapCoordinate;
			}

			/**
			* Same as the getShadowCoord; but optimized for single cascade
			*/
			inline float4 getShadowCoord_SingleCascade( float4 wpos )
			{
				return float4( mul (uWorldToShadow0, wpos).xyz, 0);
			}

			/**
			* Get camera space coord from depth and inv projection matrices
			*/
			inline float3 computeCameraSpacePosFromDepthAndInvProjMat(v2f i)
			{
				float zdepth = SAMPLE_DEPTH_TEXTURE(gCameraDepthTexture, i.uv.xy);

				float4 clipPos = float4(i.uv, zdepth, 1.0);
				clipPos.xyz = 2.0 * clipPos.xyz - 1.0;
				float4 camPos = mul(uCameraInvProjection, clipPos);
				camPos.xyz /= camPos.w;
				return camPos.xyz;
			}

			/**
			* Get camera space coord from depth and info from VS
			*/
			inline float3 computeCameraSpacePosFromDepthAndVSInfo(v2f i)
			{
				float depth = SAMPLE_DEPTH_TEXTURE(gCameraDepthTexture, i.uv.xy);

				// 0..1 linear depth, 0 at camera, 1 at far plane.
				depth = Linear01Depth (_ZBufferParams,depth);
				return i.ray * depth;
			}

			v2f vert (appdata_base v)
			{
				v2f o;
				o.pos = mul( uMVPMatrix, v.vertex );
				o.uv = v.texcoord;
				o.ray = v.normal;
				return o;
			}

			float4 frag(v2f i) : SV_TARGET
			{	
				float3 vpos = computeCameraSpacePosFromDepthAndVSInfo(i);
				//float3 vpos = computeCameraSpacePosFromDepthAndInvProjMat(i);

				float4 wpos = mul (uCameraToWorld, float4(vpos,1));

				float4 cascadeWeights = GET_CASCADE_WEIGHTS (wpos, vpos.z * (-1.0));
				float4 shadowCoord = GET_SHADOW_COORDINATES(wpos, cascadeWeights);

				#if defined(SHADOWS_SOFT)
					float shadow = SampleShadowmap_PCF7x7Tent(shadowCoord,gShadowMapTexture_TexelSize); 
					//float shadow = SampleShadowmap_PCF_NxN(shadowCoord,7,gShadowMapTexture_TexelSize);
				#else
					//1 tap hard shadow
					float shadow = SAMPLE_SHADOW(gShadowMapTexture, shadowCoord); 
				#endif

				shadow = lerp(uLightShadowData.r, 1.0, shadow);
				shadow = saturate(shadow + calcuteShadowFade(wpos, vpos)); 
				return shadow;
			}

			ENDCG
		}
	}
}